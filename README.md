# shMock - A simple test framework for shell scripts such as sh/bash/groovy

## License
license AGPL-3.0 This code and the package of shMock are free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License, version 3, as published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License, version 3, along with this program. If not, see http://www.gnu.org/licenses/

## A short background
I use to recode times sepent for stories/cards when I work on a project by using time tracker tools.
It helps to analyze jobs and improving way of workings for next steps and future projects.

During a test automation job to automate E2E tests/ and improving a continuous testing flow I realize
that the time spent to fix shell scripts bugs and issues (in this case the scripts that mostly were coded on
bash and groovy) is more than 40% of the total recoded times.

Scripts usually are not so complicated. The main idea of using a script is to packaging a group of commands
needed to be run together to have a certain output.
In the case of scripts for a automation flow such as CI flow, CD or CT flow, most challenges are
values used by scripts.
Most of values and parameters are generated by hosts (such as Jenkins, gerrit...) that scripts run under.
Moreover accesses and permissions can make it little bit more complicated, for example when a script is run by Jenkins
that the Jenkins it self is run under Tomcat.

Anyways a WOW optimization was started and the first idea was to use a real test system for scripts to decrease numbers of faced issues after being implemented to the main flow.

## What shMock is
shMock is a practical framework to develop tests for shell scripts such as sh/bash/groovy.
The framework contains several principals and also a set of pre-coded tools to write and running tests.
shMock is developed pn a private repo and its GitHub fork is only updated for major changes and hotfixes.

# An overview of shMock
If you are familiar with GMock and other standard test frameworks, you have already know how to work with shMock!
shMock is based on a very simple idea to mock and stubbing commands and functions used with a shell script to have control how a bunch of shell script lines works together.
The libraries provided by shMock help to automate steps to develop scripts especially CI/DI scripts to make it faster and more structured.
Both on development processes flows and seystem automations specially Linux based embededed systems scripts plays big role.
< NEED TO BE UPDATED >

# Quick start
Using shMock framework itself is not difficult.
< NEED TO BE UPDATED >

* Example 1:
```
#!/bin/bash
#: jenkinsjob test
#:
#: File : jenkinsjob.test.sh
#
#
# Nexttop 2023-2025 (nexttop.se)
# Maintenance nexttop -> hossein a.t. (osxx.com)
#---------------------------------------
## Import libraries
TESTORIGINALSCRIPT_PATH=$( dirname $(realpath "$0") )
SCRIPT_PATH=$( dirname "$0")
SCRIPT_NAME=jenkinsjob

[ -f $TESTORIGINALSCRIPT_PATH/${SCRIPT_NAME}.sh ] &&
	. $TESTORIGINALSCRIPT_PATH/${SCRIPT_NAME}.sh

[ -f $TESTORIGINALSCRIPT_PATH/${SCRIPT_NAME}.stubs.shinc ] &&
	. $TESTORIGINALSCRIPT_PATH/${SCRIPT_NAME}.stubs.shinc
testExpects="test.expect.shinc"
[ -f $TESTORIGINALSCRIPT_PATH/$testExpects ] &&
	. $TESTORIGINALSCRIPT_PATH/$testExpects

#*
#*  @description    Test setup
#*
#*  @param
#*
#*  @return			0 SUCCESS, > 0 FAILURE
#*
function testSetup()
{
	return 0
}

#*
#*  @description    Test teardown
#*
#*  @param
#*
#*  @return			0 SUCCESS, > 0 FAILURE
#*
function testTeardown()
{
	return 0
}

#*
#*  @description    Test jenkinsjob
#*  	Test jenkinsjob when :
#*  		- The report file is found
#*
#*  @param
#*
#*  @return			0 SUCCESS, > 0 FAILURE
#*
#@TEST
function TEST_JENKINSJOB_REPORTFOUND ()
{
    ADDMOCK grep
    ADDMOCK ssh
    ADDMOCK isFileExist $(mockCreateParamList {0,}) $(mockCreateParamList {'-',})
    ADDMOCK isDirExist $(mockCreateParamList {0,}) $(mockCreateParamList {'-',})

	output=$(JenkinsJob -jenkinsjob -patchnumber 11 -patchrevision 12223 -changenumber 734223748 \
		-project testproject -workspace $TESTORIGINALSCRIPT_PATH/testdata)
    JenkinsJobExitCode=$?
    [ $JenkinsJobExitCode -ne 0 ] &&
        echo -e "---\n$output\n---\n" &&
        return 1

    ExpectCalls grep:0 ssh:0 isFileExist:1 isDirExist:0
    [ $? -ne 0 ] &&
        return 1

	return 0
}

# Main - run tests
#---------------------------------------
testGroup=""
#testGroup=WORKING
TEST_CASES=( $(grep -P -i -A1 "^#@TEST\s*$testGroup" $0 | grep '^\s*function' | cut -d' ' -f2) )

exitCode=0
$(testSetup)
for testCase in "${TEST_CASES[@]}"
do
    TESTWORK_DIR=$(bash -c "mktemp -d")
    export TESTWORK_TEMPORARYFOLDER=$TESTWORK_DIR

    echo -e "\n$testCase"

    echo "[RUN]"
    exitCode=1
    $testCase
    exitCode=$?
    [ $exitCode -ne 0 ] &&
        echo "[FAILED]" &&
        exitCode=1 &&
        break

    echo "[PASSED]"

    RESETMOCKS
    unset TESTWORK_TEMPORARYFOLDER
    bash -c "rm -r \"$TESTWORK_DIR\""
done
$(testTeardown)

[ $exitCode -ne 0 ] &&
    exit 1

exit 0

```

* Example 2
```
#*
#*  @description    Test adding a new host who does not exist
#*
#*  @param
#*
#*  @return            0 SUCCESS, > 0 FAILURE
#*
#@TEST
function TEST_WHMAN_ADDHOST ()
{
    # Add a new host to a group who does not exist
    #----
    ADDMOCK grep
    ADDMOCK cut
    ADDMOCK tail
    ADDMOCK sed
    ADDMOCK cp
    ADDMOCK cat
    ADDMOCK find
    ADDMOCK mkdir
    ADDMOCK which $(mockCreateParamList {0,}) $(mockCreateParamList {'docker-path',})
    ADDMOCK docker $(mockCreateParamList {0,0,}) $(mockCreateParamList {'true','1.1.1.1'})

    basePath=$TESTORIGINALSCRIPT_PATH/testdata/webhost
    startUID=9001
    startGID=9001
    userName=sitec
    siteName=$userName
    groupName=newgroup

    output=$(addHost $basePath $startUID $siteName $startGID $groupName)
    addHostExitCode=$?
    [ $addHostExitCode -ne 0 ] &&
        echo -e "---\n$output\n---\n" &&
        return 1

    expectExtraInfo=$(ExpectOutput "grep" "^sitec:.:.*:.*$" '1')
    ExpectOutputExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputExitcode -ne 0 ] &&
        return 1

    expectExtraInfo=$(ExpectOutput "grep" "^newgroup:.:.*:.*$" '2')
    ExpectOutputExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputExitcode -ne 0 ] &&
        return 1


    expectExtraInfo=$(ExpectOutput "sed" "s/newgroup:x:9003:/newgroup:x:9003:sitec/g" '1')
    ExpectOutputExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputExitcode -ne 0 ] &&
        return 1

    expectExtraInfo=$(ExpectOutputs "grep//^newgroup:.:.*:.*$" "grep//etc/group")
    ExpectOutputsExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputsExitcode -ne 0 ] &&
        return 1

    ExpectCalls grep:14 cut:11 tail:11 sed:12 cp:5 cat:3 mkdir:1 which:1 docker:2
    [ $? -ne 0 ] &&
        return 1

    RESETMOCKS

    # Add a new host to a group who exists
    #----
    ADDMOCK grep
    ADDMOCK cut
    ADDMOCK tail
    ADDMOCK sed
    ADDMOCK cp
    ADDMOCK cat
    ADDMOCK find
    ADDMOCK mkdir
    ADDMOCK which $(mockCreateParamList {0,}) $(mockCreateParamList {'docker-path',})
    ADDMOCK docker $(mockCreateParamList {0,0,}) $(mockCreateParamList {'true','1.1.1.1'})

    userName=sited
    siteName=$userName
    groupName=newgroup

    output=$(addHost $basePath $startUID $siteName $startGID $groupName)
    addHostExitCode=$?
    [ $addHostExitCode -ne 0 ] &&
        echo -e "---\n$output\n---\n" &&
        return 1

    expectExtraInfo=$(ExpectOutput "grep" "^sited:.:.*:.*$" '1')
    ExpectOutputExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputExitcode -ne 0 ] &&
        return 1

    expectExtraInfo=$(ExpectOutput "grep" "^newgroup:.:.*:.*$" '2')
    ExpectOutputExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputExitcode -ne 0 ] &&
        return 1

    expectExtraInfo=$(ExpectOutput "sed" "s/newgroup:x:9003:sitec/newgroup:x:9003:sitec,sited/g" '1')
    ExpectOutputExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputExitcode -ne 0 ] &&
        return 1

    expectExtraInfo=$(ExpectOutputs "grep//^newgroup:.:.*:.*$" "grep//etc/group")
    ExpectOutputsExitcode=$?
    [ "$expectExtraInfo" != "" ] &&
        echo -e "$expectExtraInfo"
    [ $ExpectOutputsExitcode -ne 0 ] &&
        return 1

    ExpectCalls grep:13 cut:10 tail:10 sed:12 cp:5 cat:3 mkdir:1 which:1 docker:2
    [ $? -ne 0 ] &&
        return 1

    RESETMOCKS

    # Verify the added host
    #----
    ADDMOCK which $(mockCreateParamList {0,}) $(mockCreateParamList {'docker-path',})
    ADDMOCK docker $(mockCreateParamList {0,0,0,0,0,0,}) $(mockCreateParamList {'true','sitec','newgroup','true','sited','newgroup',})

    userName=sitec
    siteName=$userName
    VerifyOutput=$(verifyHost $basePath $siteName $groupName)
    verifyHostExitcode=$?
    [ $verifyHostExitcode -ne 0 ] &&
        echo -e "$VerifyOutput" &&
        return 1
    userName=sited
    siteName=$userName
    VerifyOutput=$(verifyHost $basePath $siteName $groupName)
    verifyHostExitcode=$?
    [ $verifyHostExitcode -ne 0 ] &&
        echo -e "$VerifyOutput" &&
        return 1

    ExpectCalls which:2 docker:6

    return 0
}

```
## Jenkinsjob - A very simple example
This example shows how to test a script that is developed to use with in a groovy script.
The groovy script used by this example is only one line that calls a bash script and it is not considered by this example.

* `jenkinsjob.sh` - The main script
* `jenkinsjobshelper.shinc` - provide some helper functions used by `jenkinsjob.sh`
* `jenkinsjob.test.sh` - `jenkinsjob.sh` tests

need-to-be-updated
